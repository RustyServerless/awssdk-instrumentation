// OTel-native backend

use std::{env, mem::ManuallyDrop, pin::Pin, task};

use opentelemetry::{
    Context, KeyValue,
    trace::{SpanBuilder, SpanContext, SpanKind, TraceContextExt, TraceState, Tracer},
};
use opentelemetry_semantic_conventions::attribute as semco;

use pin_project::{pin_project, pinned_drop};

use super::{InstrumentedFuture, Instrumentor, utils::XRayTraceHeader};

#[derive(Debug, Clone)]
pub struct OtelInstrumentor;

#[pin_project(PinnedDrop)]
pub struct OtelInstrumentedFuture<Fut: Future> {
    #[pin]
    future: ManuallyDrop<Fut>,
    ctx: Context,
}

impl<Fut: Future> Future for OtelInstrumentedFuture<Fut> {
    type Output = Fut::Output;

    fn poll(self: Pin<&mut Self>, cx: &mut task::Context<'_>) -> task::Poll<Self::Output> {
        let this = self.project();
        // SAFETY: As long as `ManuallyDrop<T>` does not move, `T` won't move
        //         and `future` is valid, because `ManuallyDrop::drop` is called
        //         only inside `Drop` of the `OtelInstrumentedFuture`.
        let future = unsafe { this.future.map_unchecked_mut(|v| &mut **v) };
        let _guard = this.ctx.clone().attach();
        future.poll(cx)
    }
}

#[pinned_drop]
impl<Fut: Future> PinnedDrop for OtelInstrumentedFuture<Fut> {
    fn drop(self: std::pin::Pin<&mut Self>) {
        let this = self.project();
        let _guard = this.ctx.clone().attach();

        // SAFETY: 1. `Pin::get_unchecked_mut()` is safe, because this isn't
        //             different from wrapping `T` in `Option` and calling
        //             `Pin::set(&mut this.inner, None)`, except avoiding
        //             additional memory overhead.
        //         2. `ManuallyDrop::drop()` is safe, because
        //            `PinnedDrop::drop()` is guaranteed to be called only
        //            once.
        unsafe { ManuallyDrop::drop(this.future.get_unchecked_mut()) }
    }
}

impl<Fut: Future> InstrumentedFuture for OtelInstrumentedFuture<Fut> {
    type Fut = Self;
}

impl Instrumentor for OtelInstrumentor {
    type IFut<F: Future> = OtelInstrumentedFuture<F>;

    fn instrument<F: Future>(inner: F, context: super::InvocationContext) -> Self::IFut<F> {
        let tracer = opentelemetry::global::tracer("");

        let span_builder = SpanBuilder::from_name(
            env::var("AWS_LAMBDA_FUNCTION_NAME")
                .ok()
                .unwrap_or_default(),
        )
        .with_kind(SpanKind::Server)
        .with_attributes([
            KeyValue::new(semco::FAAS_TRIGGER, context.trigger.to_string()),
            KeyValue::new(semco::CLOUD_RESOURCE_ID, context.function_arn),
            KeyValue::new(semco::FAAS_INVOCATION_ID, context.request_id),
            KeyValue::new(semco::CLOUD_ACCOUNT_ID, context.account_id),
            KeyValue::new(semco::FAAS_COLDSTART, context.is_coldstart),
        ]);

        // Parse XRay TraceId as an XRayTraceHeader and use it to create a parent Span
        // This will enable Xray to link this segments with the overall trace generated by the Lambda service
        let ctx = if let Some(XRayTraceHeader {
            trace_id,
            parent_id,
            sampled,
        }) = context.xray_trace_header
        {
            let otel_context = opentelemetry::Context::new().with_remote_span_context(
                SpanContext::new(trace_id, parent_id, sampled, true, TraceState::NONE),
            );
            let span =
                tracer.build_with_context(span_builder.with_trace_id(trace_id), &otel_context);

            otel_context.with_span(span)
        } else {
            let span = tracer.build(span_builder);
            opentelemetry::Context::current().with_span(span)
        };
        OtelInstrumentedFuture {
            future: ManuallyDrop::new(inner),
            ctx,
        }
    }
}
